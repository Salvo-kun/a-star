\section{A-Star Implementation}
\label{Sec:implementation}

A-Star is a best-first search algorithm based on the use of a heuristic function which estimates the cost from a point to a destination node.

Both implementations are based on two set, the OPEN and the CLOSE one. The first is implemented using a priority queue (our heap \ref{heap}) and contains nodes that have been discovered but not expanded yet, the second with a hash table (\ref{hash_table}) and contains nodes that have been expanded.

All vertexs contains a link to a parent vertex which is used to keep trace of the path found by the algorithm, at the end the solution is inserted in a stack (\ref{stack}) pushing from the goal node and going backward.

\subsection{Sequential A*}

Starting from pseudo-code \cite{bibParAstar}

\begin{alltt}
    1 Initialize OPEN to s_0;
    2 {\bf while} OPEN \(\neq\) 0 {\bf do}
    3    Get and remove from OPEN a node n with a smallest f(n);
    4    Add n to CLOSED;
    5   {\bf if} n is a goal node {\bf then}
    6       Return solution path from \(s_0\) to n;
    7   {\bf for} every successor n' of n {\bf do}
    8       g_1 = g(n) + c(n, n');
    9      {\bf if} n' \(\in\) CLOSED {\bf then}
    10         {\bf if} g_1 < g(n') {\bf then}
    11             Remove n' from CLOSED and add it to OPEN;
    12         {\bf else}
    13             continue;
    14     {\bf else}
    15         {\bf if} n' \(\notin\) OPEN {\bf then}
    16             Add n' to OPEN;
    17         {\bf else if} g_1 \(\geq\) g(n') {\bf then}
    18             continue;
    19     Set g(n') = g_1;
    20     Set f(n') = g(n') + h(n');
    21     Set parent(n') = n;
    22 Return failure (no path exists);
\end{alltt}

Where
\begin{itemize}
    \item $s_0$ : is the starting node
    \item $g(n)$ : is the cost of the best known path from $s_0$ to $n$
    \item $h(n)$ : is the heuristic function
    \item $f(n)$ : is the sum $g(n) + h(n)$, used in the OPEN set to calculate the priority
\end{itemize}

\subsection{Parallel A*}

Implementation of the decentralized AStar algorithm, where each thread has its own CLOSED and OPEN set.
When a thread discovers a neighbouring node it choses the thread that will expand it and sends a message to it.
\\
When a thread finds a solution, it compares the cost with the global one and if it is lower, it changes the cost with the new one (the global cost is protected with a lock).

\subsubsection{Pseudo-code}

Starting from pseudo-code \cite{bibParAstar}

\begin{alltt}
    1 Initialize OPENp for each thread p;
    2 Initialize incumbent.cost = \(\infty\);
    3 Add s0 to OPENComputeRecipient(s0);
    4 In parallel, on each thread p, execute 5-31;
    5 {\bf while} TerminateDetection() {\bf do}
    6    {\bf while} BUFFERp \(\neq\) 0 {\bf do}
    7       Get and remove from BUFFERp a triplet (n', g1, n);
    8       {\bf if} n' \(\in\) CLOSEDp {\bf then}
    9           {\bf if} g1 < g(n') {\bf then}
    10              Remove n' from CLOSEDp and add it to OPENp;
    11          {\bf else}
    12              Continue;
    13      {\bf else}
    14          {\bf if} n' \(\notin\) OPENp {\bf then}
    15              Add n' to OPENp;
    16          {\bf else if} g1 \(\geq\) g(n') {\bf then}
    17              Continue;
    18      Set g(n') = g1;
    19      Set f(n') = g(n') + h(n');
    20      Set parent(n') = n;
    21   {\bf if} OPENp = 0 {\bf or} Smallest f(n) value of n \(\in\) OPENp \(\geq\) incumbent.cost {\bf then}
    22      Continue;
    23   Get and remove from OPENp a node n with a smallest f(n);
    24   Add n to CLOSEDp;
    25   {\bf if} n is a goal node {\bf then}
    26      {\bf if} path cost from s0 to n < incumbent.cost {\bf then}
    27          incumbent = path from s0 to n;
    28          incumbent.cost = path cost from s0 to n;
    29   {\bf for} every successor n' of n {\bf do}
    30      Set g1 = g(n) + c(n , n');
    31      Add (n', g1, n) to BUFFER ComputeRecipient(n);
    32 {\bf if} incumbent.cost = \(\infty\) {\bf then}
    33    Return failure (no path exists);
    34 {\bf else}
    35    Return solution path from s0 to n;
\end{alltt}

Where
\begin{itemize}
    \item $BUFFER$ : structure used for thread communication (\ref{thread_buf})
    \item $incumbent$ : the shared best known path
    \item $TerminateDetection$ : function to check if the path search is completed \ref{terminate}
    \item $ComputeRecipient$ : function that choses the thread that will expand the node (\ref{compute_reci})
\end{itemize}

\subsubsection{Compute recipient}
\label{compute_reci}

A Function that is able to map the nodeId into a thread identifier, and which is used to decide to which thread send a message to with the node to expand.
This function can considerably change the performance of the algorithm.
\\ 
We provided two different implementation:
\\
The basic module is the simplest one and it is computed as: \\
\begin{center}
    $node\_id \; \% \;  number\_of\_threads$
\end{center}

A more efficient function, but still simple to implement, is the multiplicative hashing computed as \cite{bibVideoMulHash}: \\
\begin{center}
    $ h(node\_id) =((a*node\_id \; + \; b) \; \% \; p) \; \% \; number\_of\_threads $  
    \\ 
    where:
    \begin{itemize}
        \item $p$: large prime number (we used INT\_MAX =  $ 2^{31}-1 $)
        \item $a$: random integer [1,p-1]
        \item $b$: random integer [0,p-1]
    \end{itemize}
\end{center}


\subsubsection{Thread communication}
\label{thread_buf}

A message queue (\ref{message_queue}) structure is used to allows threads to communicate: a thread computes the recipient and sends a message using the thread destination with the node and cost. 

\subsubsection{Terminate condition}
\label{terminate}

When a thread has its OPEN set empty or there aren't any elements that will improve the cost of the path, it sets its termination\_flag.
A thread waits on its condition variable only if it has no message pending and its termination\_flag is set, if all other threads are waiting the program terminates instead.
When a thread sends a message to another one, it signals its condition variable in order to wake it up.

\begin{alltt}
    1 lock mutex
    2{\bf while} termination_flags[this_thread] {\bf and} BUFFER(this_thread) = 0 {\bf and}
            not program_terminated {\bf do}
    3    {\bf if} counter \( \geq \) n_threads - 1 {\bf and} all BUFFER empty {\bf then}
    4        program_terminated = 1
    5        signal all condition variables
    6    {\bf else}
    7        counter++
    8        wait on condition variable of this_thread
    9        counter--
    10 unlock mutex
    11{\bf if} program_terminated {\bf then}
    12   return true
    13{\bf else}
    14   return false
\end{alltt}

Where
\begin{itemize}
    \item $termination\_flags$: array of flags set by a thread when the OPEN set is empty or does not have any node with a minor cost then the actual path
    \item $program\_terminated$: flag set by last thread awake when it detects the termination of the program
    \item $counter$: counter of sleeping threads
    \item $mutex$: global mutex to protect all condition variables
    \item $BUFFER$: message queue of each thread
\end{itemize}

